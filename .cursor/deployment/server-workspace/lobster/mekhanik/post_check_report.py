#!/usr/bin/env python3
"""Post-check reporter for Lobster Mekhanik 24h soak.

Checks:
- duplicates with legacy Mekhanik job (did legacy run during window?)
- alert spam proxy (count of incidents types generated by lobster runner)
- state_write_failed / restart_loop_blocked / circuit_breaker_triggered from metrics JSONL

Emits a short JSON summary to stdout.
"""

from __future__ import annotations

import json
import os
from datetime import datetime, timedelta, timezone

METRICS = os.path.expanduser("~/.openclaw/.runtime/mekhanik-lobster-metrics.jsonl")
INCIDENTS = os.path.expanduser("~/.openclaw/workspace/data/incidents.jsonl")

LEGACY_MEKHANIK_JOB_ID = "bef4ddfa-1fd8-4c64-9495-79d851f4f5f0"


def read_jsonl(path: str) -> list[dict]:
    if not os.path.exists(path):
        return []
    out = []
    with open(path, "r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            try:
                out.append(json.loads(line))
            except Exception:
                continue
    return out


def parse_ts(ts: str) -> datetime:
    if ts.endswith("Z"):
        ts = ts[:-1] + "+00:00"
    return datetime.fromisoformat(ts)


def main() -> None:
    now = datetime.now(timezone.utc)
    since = now - timedelta(hours=24)

    metrics = [r for r in read_jsonl(METRICS) if isinstance(r.get("ts"), str)]
    m24 = []
    for r in metrics:
        try:
            if parse_ts(r["ts"]) >= since:
                m24.append(r)
        except Exception:
            continue

    agg = {
        "runs": len(m24),
        "planned_safe_auto": sum(int(r.get("planned_safe_auto", 0) or 0) for r in m24),
        "planned_risky": sum(int(r.get("planned_risky", 0) or 0) for r in m24),
        "state_write_failed": sum(int(r.get("state_write_failed", 0) or 0) for r in m24),
        "restart_loop_blocked": sum(int(r.get("restart_loop_blocked", 0) or 0) for r in m24),
        "circuit_breaker_triggered": sum(int(r.get("circuit_breaker_triggered", 0) or 0) for r in m24),
    }

    # Duplicates with legacy: check if legacy wrote any resolved/escalated by source=mekhanik in last 24h
    incidents = [r for r in read_jsonl(INCIDENTS) if isinstance(r.get("ts"), str)]
    i24 = []
    for r in incidents:
        try:
            if parse_ts(r["ts"]) >= since:
                i24.append(r)
        except Exception:
            continue

    legacy_activity = 0
    for r in i24:
        if r.get("source") == "mekhanik":
            legacy_activity += 1

    # Lobster runner shouldn't append incidents in plan-only; but we can detect if any were written.
    lobster_activity = 0
    for r in i24:
        if r.get("source") in ("mekhanik-lobster", "lobster-mekhanik"):
            lobster_activity += 1

    ready = (
        agg["runs"] >= 24 and
        agg["state_write_failed"] == 0 and
        agg["restart_loop_blocked"] == 0 and
        agg["circuit_breaker_triggered"] == 0
    )

    out = {
        "ts": now.isoformat().replace("+00:00", "Z"),
        "window": "24h",
        "metrics": agg,
        "duplicates_with_legacy": {
            "legacy_incident_rows_24h": legacy_activity,
            "lobster_incident_rows_24h": lobster_activity,
            "note": "plan-only runner should be 0 lobster rows; legacy may be >0 if it repaired incidents",
        },
        "alert_spam": {
            "proxy": "no message events counted; use incidents+metrics only",
            "state_write_failed": agg["state_write_failed"],
        },
        "recommendation": "ready" if ready else "not_ready",
    }

    print(json.dumps({"ok": True, "summary": out}, ensure_ascii=False))


if __name__ == "__main__":
    main()
