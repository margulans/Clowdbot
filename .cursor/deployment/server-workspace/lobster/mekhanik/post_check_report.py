#!/usr/bin/env python3
"""Post-check reporter for Lobster Mekhanik 24h soak.

Checks:
- duplicates with legacy Mekhanik job (did legacy run during window?)
- alert spam proxy (count of incidents types generated by lobster runner)
- state_write_failed / restart_loop_blocked / circuit_breaker_triggered from metrics JSONL

Emits a short JSON summary to stdout.
"""

from __future__ import annotations

import json
import os
from datetime import datetime, timedelta, timezone

METRICS = os.path.expanduser("~/.openclaw/.runtime/mekhanik-lobster-metrics.jsonl")
INCIDENTS = os.path.expanduser("~/.openclaw/workspace/data/incidents.jsonl")

# Scope classification
LOBSTER_SOURCES = {"mekhanik-lobster", "lobster-mekhanik"}
LOBSTER_JOB_IDS: set[str] = set()  # fill if/when lobster writes jobId-scoped incidents
LEGACY_JOB_IDS = {
    "bef4ddfa-1fd8-4c64-9495-79d851f4f5f0",  # ğŸ”§ ĞœĞµÑ…Ğ°Ğ½Ğ¸Ğº (legacy)
    "ce006db5-350b-44be-baef-8b216ed687e4",  # Auto-commit: Git sync (legacy)
    "582cc3f0-9941-4e74-ae77-0afac52c6258",  # Ğ’ĞµÑ‡ĞµÑ€Ğ½Ğ¸Ğ¹ Ğ´Ğ°Ğ¹Ğ´Ğ¶ĞµÑÑ‚ @newsneiron (legacy)
    "89db97f7-e05e-4e3b-990b-fefc1815e7d7",  # ğŸ•µï¸ Ğ§ĞµĞºĞ¸ÑÑ‚ (Ğ½Ğ¾Ñ‡ÑŒ) (legacy)
}


def read_jsonl(path: str) -> list[dict]:
    if not os.path.exists(path):
        return []
    out = []
    with open(path, "r", encoding="utf-8") as f:
        for line in f:
            line = line.strip()
            if not line:
                continue
            try:
                out.append(json.loads(line))
            except Exception:
                continue
    return out


def parse_ts(ts: str) -> datetime:
    if ts.endswith("Z"):
        ts = ts[:-1] + "+00:00"
    return datetime.fromisoformat(ts)


def classify_scope(inc: dict) -> str:
    job_id = inc.get("jobId")
    src = inc.get("source")
    if src in LOBSTER_SOURCES or (isinstance(job_id, str) and job_id in LOBSTER_JOB_IDS):
        return "lobster"
    if isinstance(job_id, str) and job_id in LEGACY_JOB_IDS:
        return "legacy"
    return "unknown"


def scoped_incident_deltas(incidents: list[dict], since_ts: datetime) -> dict:
    total = lobster = legacy = unknown = 0
    for r in incidents:
        ts = r.get("ts")
        if not isinstance(ts, str):
            continue
        try:
            if parse_ts(ts) < since_ts:
                continue
        except Exception:
            continue
        total += 1
        scope = classify_scope(r)
        if scope == "lobster":
            lobster += 1
        elif scope == "legacy":
            legacy += 1
        else:
            unknown += 1
    return {
        "incidents_total_delta": total,
        "incidents_lobster_scoped_delta": lobster,
        "incidents_legacy_scoped_delta": legacy,
        "incidents_unknown_scoped_delta": unknown,
    }


def main() -> None:
    now = datetime.now(timezone.utc)
    since = now - timedelta(hours=24)

    metrics = [r for r in read_jsonl(METRICS) if isinstance(r.get("ts"), str)]
    m24 = []
    for r in metrics:
        try:
            if parse_ts(r["ts"]) >= since:
                m24.append(r)
        except Exception:
            continue

    agg = {
        "runs": len(m24),
        "planned_safe_auto": sum(int(r.get("planned_safe_auto", 0) or 0) for r in m24),
        "planned_risky": sum(int(r.get("planned_risky", 0) or 0) for r in m24),
        "state_write_failed": sum(int(r.get("state_write_failed", 0) or 0) for r in m24),
        "restart_loop_blocked": sum(int(r.get("restart_loop_blocked", 0) or 0) for r in m24),
        "circuit_breaker_triggered": sum(int(r.get("circuit_breaker_triggered", 0) or 0) for r in m24),
        "message_events_total": sum(int(r.get("message_events_total", 0) or 0) for r in m24),
        "message_events_suppressed": sum(int(r.get("message_events_suppressed", 0) or 0) for r in m24),
        "message_events_by_type": {
            "alert": sum(int((r.get("message_events_by_type") or {}).get("alert", 0) or 0) for r in m24),
            "escalation": sum(int((r.get("message_events_by_type") or {}).get("escalation", 0) or 0) for r in m24),
            "other": sum(int((r.get("message_events_by_type") or {}).get("other", 0) or 0) for r in m24),
        },
    }

    # Duplicates with legacy: check if legacy wrote any resolved/escalated by source=mekhanik in last 24h
    incidents = [r for r in read_jsonl(INCIDENTS) if isinstance(r.get("ts"), str)]
    i24 = []
    for r in incidents:
        try:
            if parse_ts(r["ts"]) >= since:
                i24.append(r)
        except Exception:
            continue

    legacy_activity = 0
    for r in i24:
        if r.get("source") == "mekhanik":
            legacy_activity += 1

    # Lobster runner shouldn't append incidents in plan-only; but we can detect if any were written.
    lobster_activity = 0
    for r in i24:
        if r.get("source") in ("mekhanik-lobster", "lobster-mekhanik"):
            lobster_activity += 1

    # 30m period => expected_runs_24h=48; accept >=46 to tolerate minor scheduling jitter
    ready = (
        agg["runs"] >= 46 and
        agg["state_write_failed"] == 0 and
        agg["restart_loop_blocked"] == 0 and
        agg["circuit_breaker_triggered"] == 0
    )

    deltas = scoped_incident_deltas(i24, now - timedelta(hours=2))
    gate_status = "ok"
    if deltas["incidents_unknown_scoped_delta"] > 0:
        gate_status = "needs_review"
    if deltas["incidents_lobster_scoped_delta"] > 0:
        gate_status = "blocked"

    out = {
        "ts": now.isoformat().replace("+00:00", "Z"),
        "window": "24h",
        "metrics": agg,
        "duplicates_with_legacy": {
            "legacy_incident_rows_24h": legacy_activity,
            "lobster_incident_rows_24h": lobster_activity,
            "note": "plan-only runner should be 0 lobster rows; legacy may be >0 if it repaired incidents",
        },
        "incident_scope": deltas,
        "gate_status": gate_status,
        "alert_spam": {
            "proxy": "no message events counted; use incidents+metrics only",
            "state_write_failed": agg["state_write_failed"],
        },
        "recommendation": "ready" if (ready and gate_status == "ok") else ("needs_review" if gate_status == "needs_review" else "not_ready"),
    }

    print(json.dumps({"ok": True, "summary": out}, ensure_ascii=False))


if __name__ == "__main__":
    main()
